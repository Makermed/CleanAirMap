import { arg, floatArg, objectType, enumType } from 'nexus'
import { extendType } from 'nexus'
import { stringArg, nonNull, intArg } from 'nexus'

export const LocationEnum = enumType({
    name: "LocationEnum",
    members: {
      ALL: 999,
      SHOP: 0,
      MUSEUM: 1,
      BAR: 2,
      CAFE: 3,
      HOSPITAL: 4,
      TRAIN: 5,
      RESTAURANT: 6,
      LIBRARY: 7,
      ARTS: 8,
      HOTEL: 9,
      GASSTATION: 10,
      PARKING: 11,
      MOVIE: 12,
      PARK: 13,
      CAMERA: 14,
      ARENA: 15,
      PHARMACY: 16,
      SCHOOL: 17,
      BEAUTY: 18,
      FITNESS: 19,
      SENIORS: 20,
      PROFESSIONAL: 21,
      DENTISTS: 22,
      DINING: 23,
      WORSHIP: 24
    },
    description: 'The type of location, eg. shop, place of worship, hospital, etc.'
  })

export const Location = objectType({
    name: 'Location',
    sourceType: 'LocationModel',
    definition(t) {
        t.int('locationId'),
        t.string('name'),
        t.field('type', { type: 'LocationEnum' })
        t.string('street'),
        t.string('locality'),
        t.string('place'),
        t.string('district'),
        t.string('region'),
        t.string('postcode'),
        t.float('latitude'),
        t.float('longitude'),
        t.string('description'),
        t.float('avgCo2'),
        t.int('created_id'),
        t.datetime('created_at')
    },
})

export const LocationQuery = extendType({
    type: 'Query',
    definition(t) {
        t.list.field('locations', {
            type: 'Location',
            args: { locationId: intArg()},
            async resolve(_root, _args, ctx) {
                if (_args == null || _args.locationId == null) {
                return ctx.db.locationDAO.getMany();
            }
                if (_args != null && _args.locationId != null) {
                    const single = await ctx.db.locationDAO.getById(_args.locationId);
                    return [ single ] ;
                }
                return null;
            }
        })
    },
})

export const LocationMutation = extendType({
    type: 'Mutation',
    definition(t) {
        t.field('createLocation', {
            type: 'Location',
            args: {
                name: nonNull(stringArg()),
                street: nonNull(stringArg()),
                locality: stringArg(),
                place: nonNull(stringArg()),
                district: stringArg(),
                region: nonNull(stringArg()),
                postcode: stringArg(),
                country: nonNull(stringArg()),
                lat: nonNull(floatArg()),
                long: nonNull(floatArg()),
                description: stringArg(),
                type: nonNull(arg({ type: 'LocationEnum' }))
            },
            async resolve(_root, args, ctx) {
                const location  = {
                    name: args.name,
                    street: args.street,
                    locality: args.locality,
                    place: args.place,
                    district: args.district,
                    region: args.region,
                    postcode: args.postcode,
                    country: args.country,
                    type: args.type,
                    latitude: args.lat,
                    longitude: args.long,
                    description: args.description,
                    avgCo2: null,
                    created_id: 1
                }
                //@ts-ignore: missing ID is okay, as it will be autogenerated
                //TODO: perhaps create a NewLocation type with no ID
                const newloc = await ctx.db.locationDAO.create( location )
                return newloc
            }
        })
    }
})